<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ProTrade Signal Engine v2 | Professional Futures Trading System</title>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600&family=Inter:wght@400;500;600;700&family=Orbitron:wght@500;600;700&display=swap" rel="stylesheet">
    <style>
        :root{--bg:#0d0f14;--bg2:#151921;--bg3:#1c222e;--card:#232936;--green:#00e676;--red:#ff5252;--gold:#ffc107;--blue:#448aff;--text:#e8eaed;--text2:#9ca3af;--text3:#6b7280;--border:#2d3548;--success:#00e676;--danger:#ff5252;--warning:#ffc107}
        *{margin:0;padding:0;box-sizing:border-box}
        body{font-family:'Inter',sans-serif;background:var(--bg);color:var(--text);min-height:100vh;line-height:1.5}
        
        header{background:linear-gradient(180deg,var(--bg2),var(--bg));border-bottom:1px solid var(--border);padding:16px 24px;position:sticky;top:0;z-index:100}
        .header-content{display:flex;justify-content:space-between;align-items:center;max-width:1600px;margin:0 auto}
        .logo{display:flex;align-items:center;gap:12px}
        .logo-icon{width:36px;height:36px;background:linear-gradient(135deg,var(--gold),#ff8c00);border-radius:8px;display:flex;align-items:center;justify-content:center;font-size:18px}
        .logo-text{font-family:'Orbitron',sans-serif;font-size:18px;font-weight:700;letter-spacing:1px}
        .logo-text span{color:var(--gold)}
        .header-stats{display:flex;gap:24px;align-items:center}
        .h-stat{display:flex;flex-direction:column;align-items:flex-end}
        .h-stat-val{font-family:'IBM Plex Mono',monospace;font-size:14px;font-weight:600}
        .h-stat-lbl{font-size:10px;color:var(--text3);text-transform:uppercase;letter-spacing:0.5px}
        .status-badge{padding:6px 12px;border-radius:4px;font-size:11px;font-weight:600;font-family:'IBM Plex Mono',monospace;display:flex;align-items:center;gap:6px}
        .status-badge.live{background:rgba(0,230,118,0.15);color:var(--green);border:1px solid var(--green)}
        .status-badge.limited{background:rgba(255,193,7,0.15);color:var(--gold);border:1px solid var(--gold)}
        .pulse{width:8px;height:8px;border-radius:50%;background:currentColor;animation:pulse 2s infinite}
        .btn{background:var(--card);border:1px solid var(--border);color:var(--text);padding:8px 14px;border-radius:4px;cursor:pointer;font-family:inherit;font-size:12px;transition:0.2s}
        .btn:hover{border-color:var(--gold)}
        .toggle{position:relative;display:inline-block;width:40px;height:20px}
        .toggle input{opacity:0;width:0;height:0}
        .toggle-slider{position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background:var(--bg3);transition:0.3s;border-radius:20px}
        .toggle-slider:before{position:absolute;content:"";height:14px;width:14px;left:3px;bottom:3px;background:var(--text);transition:0.3s;border-radius:50%}
        .toggle input:checked+.toggle-slider{background:var(--green)}
        .toggle input:checked+.toggle-slider:before{transform:translateX(20px)}
        @keyframes pulse{0%,100%{opacity:1}50%{opacity:0.4}}

        .nav-bar{background:var(--bg2);border-bottom:1px solid var(--border);padding:0 24px}
        .nav-content{max-width:1600px;margin:0 auto;display:flex;gap:4px}
        .nav-btn{background:none;border:none;padding:14px 20px;font-family:'Inter',sans-serif;font-size:13px;font-weight:500;color:var(--text2);cursor:pointer;position:relative;transition:0.2s}
        .nav-btn:hover{color:var(--text)}
        .nav-btn.active{color:var(--gold)}
        .nav-btn.active::after{content:'';position:absolute;bottom:0;left:0;width:100%;height:2px;background:var(--gold)}

        .main{max-width:1600px;margin:0 auto;padding:20px 24px;display:grid;grid-template-columns:1fr 320px;gap:20px}
        @media(max-width:1200px){.main{grid-template-columns:1fr}.sidebar{display:none}}

        .alert-banner{background:linear-gradient(90deg,rgba(255,193,7,0.1),rgba(0,230,118,0.1));border:1px solid var(--gold);border-radius:8px;padding:12px 16px;margin-bottom:20px;display:flex;align-items:center;gap:12px}
        .alert-icon{font-size:20px}
        .alert-content{flex:1}
        .alert-title{font-size:13px;font-weight:600;color:var(--gold);margin-bottom:2px}
        .alert-text{font-size:11px;color:var(--text2)}

        .stats-grid{display:grid;grid-template-columns:repeat(8,1fr);gap:12px;margin-bottom:20px}
        @media(max-width:900px){.stats-grid{grid-template-columns:repeat(4,1fr)}}
        .stat-card{background:var(--card);border:1px solid var(--border);border-radius:8px;padding:16px;text-align:center;transition:0.2s}
        .stat-card:hover{border-color:var(--gold)}
        .stat-value{font-family:'IBM Plex Mono',monospace;font-size:22px;font-weight:600;margin-bottom:4px}
        .stat-value.green{color:var(--green)}.stat-value.red{color:var(--red)}.stat-value.gold{color:var(--gold)}
        .stat-label{font-size:10px;color:var(--text3);text-transform:uppercase;letter-spacing:0.5px}
        .stat-sub{font-size:9px;color:var(--text3);margin-top:2px}

        .section-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;flex-wrap:wrap;gap:12px}
        .section-title{font-family:'Orbitron',sans-serif;font-size:14px;display:flex;align-items:center;gap:8px}
        .section-title::before{content:'';width:4px;height:16px;background:var(--gold);border-radius:2px}
        .signal-count{display:flex;align-items:center;gap:8px}
        .count-badge{padding:4px 10px;border-radius:12px;font-size:11px;font-weight:600;font-family:'IBM Plex Mono',monospace;background:rgba(0,230,118,0.15);color:var(--green);border:1px solid var(--green)}
        .count-badge.warning{background:rgba(255,193,7,0.15);color:var(--gold);border-color:var(--gold)}
        .count-badge.danger{background:rgba(255,82,82,0.15);color:var(--red);border-color:var(--red)}

        .filter-btns{display:flex;gap:6px;flex-wrap:wrap}
        .filter-btn{padding:6px 12px;border-radius:4px;border:1px solid var(--border);background:var(--card);color:var(--text2);font-size:11px;cursor:pointer;transition:0.2s;font-family:inherit}
        .filter-btn:hover{border-color:var(--text2)}
        .filter-btn.active{background:var(--gold);color:var(--bg);border-color:var(--gold)}

        .signals-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(340px,1fr));gap:16px}
        
        .signal-card{background:var(--card);border:1px solid var(--border);border-radius:10px;overflow:hidden;transition:0.3s}
        .signal-card:hover{transform:translateY(-2px);box-shadow:0 8px 24px rgba(0,0,0,0.4)}
        .signal-card.grade-a-plus{border-color:var(--gold);box-shadow:0 0 20px rgba(255,193,7,0.15)}
        .signal-card.grade-a{border-color:var(--green)}
        .signal-card.long{border-left:4px solid var(--green)}
        .signal-card.short{border-left:4px solid var(--red)}
        
        .signal-header{background:var(--bg2);padding:14px 16px;display:flex;justify-content:space-between;align-items:center}
        .signal-pair{display:flex;align-items:center;gap:10px}
        .pair-name{font-family:'Orbitron',sans-serif;font-size:16px;font-weight:600}
        .pair-timeframe{font-size:10px;color:var(--text3);padding:2px 6px;background:var(--bg);border-radius:3px}
        .signal-direction{padding:6px 14px;border-radius:4px;font-size:12px;font-weight:700;font-family:'IBM Plex Mono',monospace}
        .signal-direction.long{background:rgba(0,230,118,0.15);color:var(--green);border:1px solid var(--green)}
        .signal-direction.short{background:rgba(255,82,82,0.15);color:var(--red);border:1px solid var(--red)}
        
        .signal-body{padding:16px}
        
        .entry-zone{background:var(--bg2);border-radius:6px;padding:12px;margin-bottom:12px;display:flex;justify-content:space-between;align-items:center}
        .entry-label{font-size:11px;color:var(--text3);text-transform:uppercase;letter-spacing:0.5px}
        .entry-price{font-family:'IBM Plex Mono',monospace;font-size:18px;font-weight:600}

        .levels-grid{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:12px}
        .level-box{padding:10px;border-radius:6px}
        .level-box.sl{background:rgba(255,82,82,0.1);border:1px solid rgba(255,82,82,0.3)}
        .level-box.tp{background:rgba(0,230,118,0.1);border:1px solid rgba(0,230,118,0.3)}
        .level-label{font-size:10px;text-transform:uppercase;margin-bottom:4px}
        .level-box.sl .level-label{color:var(--red)}
        .level-box.tp .level-label{color:var(--green)}
        .level-price{font-family:'IBM Plex Mono',monospace;font-size:14px;font-weight:600}

        .checks-row{display:flex;flex-wrap:wrap;gap:6px;margin-bottom:12px}
        .check-item{font-size:10px;padding:4px 8px;border-radius:4px;display:flex;align-items:center;gap:4px}
        .check-item.pass{background:rgba(0,230,118,0.1);color:var(--green)}
        .check-item.fail{background:rgba(255,82,82,0.1);color:var(--red)}
        .check-item.neutral{background:var(--bg2);color:var(--text3)}

        .signal-metrics{background:linear-gradient(135deg,rgba(255,193,7,0.05),rgba(0,230,118,0.05));border:1px solid var(--border);border-radius:6px;padding:12px;margin-bottom:12px}
        .metrics-row{display:flex;justify-content:space-between;margin-bottom:6px}
        .metrics-row:last-child{margin-bottom:0}
        .metric{font-size:11px}
        .metric-label{color:var(--text3)}
        .metric-value{font-family:'IBM Plex Mono',monospace;font-weight:600}

        .grade-badge{display:inline-flex;align-items:center;gap:4px;padding:6px 12px;border-radius:4px;font-size:12px;font-weight:700;font-family:'Orbitron',sans-serif}
        .grade-badge.a-plus{background:linear-gradient(135deg,var(--gold),#ff8c00);color:#000}
        .grade-badge.a{background:var(--green);color:#000}
        .leverage{background:rgba(68,138,255,0.15);border:1px solid var(--blue);padding:4px 10px;border-radius:4px;color:var(--blue);font-weight:600;font-size:12px}

        .bias-indicator{display:flex;align-items:center;gap:8px;padding:8px 12px;background:var(--bg2);border-radius:6px;margin-bottom:12px}
        .bias-icon{font-size:16px}
        .bias-text{font-size:11px}
        .bias-text strong{font-weight:600}
        .bias-bullish{color:var(--green)}.bias-bearish{color:var(--red)}.bias-neutral{color:var(--text3)}

        .no-signals{text-align:center;padding:60px 20px;color:var(--text3)}
        .no-signals-icon{font-size:48px;margin-bottom:16px;opacity:0.5}
        .no-signals-title{font-size:16px;font-weight:600;margin-bottom:8px;color:var(--text2)}
        .no-signals-text{font-size:13px;max-width:400px;margin:0 auto}

        .sidebar{display:flex;flex-direction:column;gap:16px}
        .widget{background:var(--card);border:1px solid var(--border);border-radius:10px;padding:16px}
        .widget-title{font-family:'Orbitron',sans-serif;font-size:12px;font-weight:600;margin-bottom:14px;display:flex;align-items:center;gap:8px}
        .widget-title::before{content:'';width:3px;height:12px;background:var(--gold);border-radius:2px}

        .bias-gauge{text-align:center;padding:10px 0}
        .gauge-ring{width:100px;height:100px;border-radius:50%;margin:0 auto 12px;position:relative;background:conic-gradient(var(--green) 0deg 120deg,var(--gold) 120deg 240deg,var(--red) 240deg 360deg);display:flex;align-items:center;justify-content:center}
        .gauge-inner{width:70px;height:70px;background:var(--card);border-radius:50%;display:flex;flex-direction:column;align-items:center;justify-content:center}
        .gauge-value{font-family:'Orbitron',sans-serif;font-size:20px;font-weight:700}
        .gauge-label{font-size:9px;color:var(--text3);text-transform:uppercase}
        .gauge-bars{display:flex;justify-content:space-around;padding-top:12px;border-top:1px solid var(--border)}
        .gauge-bar{text-align:center}
        .gauge-bar-value{font-family:'IBM Plex Mono',monospace;font-size:14px;font-weight:600}
        .gauge-bar-label{font-size:9px;color:var(--text3)}

        .asset-bias{display:flex;flex-direction:column;gap:8px}
        .asset-row{display:flex;justify-content:space-between;align-items:center;padding:10px;background:var(--bg2);border-radius:6px}
        .asset-sym{font-family:'IBM Plex Mono',monospace;font-size:12px;font-weight:600}
        .asset-direction{padding:3px 8px;border-radius:3px;font-size:10px;font-weight:600}
        .asset-direction.long{background:rgba(0,230,118,0.15);color:var(--green)}
        .asset-direction.short{background:rgba(255,82,82,0.15);color:var(--red)}
        .asset-direction.neutral{background:var(--bg);color:var(--text3)}

        .performance-metrics{display:flex;flex-direction:column;gap:10px}
        .perf-row{display:flex;justify-content:space-between;padding:10px;background:var(--bg2);border-radius:6px}
        .perf-label{font-size:12px;color:var(--text2)}
        .perf-value{font-family:'IBM Plex Mono',monospace;font-size:13px;font-weight:600}
        .perf-value.green{color:var(--green)}.perf-value.red{color:var(--red)}

        .news-feed{display:flex;flex-direction:column;gap:8px;max-height:200px;overflow-y:auto}
        .news-item{padding:10px;background:var(--bg2);border-radius:6px;cursor:pointer;transition:0.2s}
        .news-item:hover{background:var(--bg)}
        .news-title{font-size:11px;font-weight:500;line-height:1.4;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden}
        .news-time{font-size:9px;color:var(--text3);margin-top:4px}

        .disclaimer{background:var(--bg2);border:1px solid var(--border);border-radius:8px;padding:16px;margin-top:20px}
        .disclaimer-title{font-size:12px;font-weight:600;color:var(--gold);margin-bottom:8px;display:flex;align-items:center;gap:6px}
        .disclaimer-text{font-size:11px;color:var(--text3);line-height:1.6}

        .loading{text-align:center;padding:60px 20px}
        .spinner{width:40px;height:40px;border:3px solid var(--border);border-top-color:var(--gold);border-radius:50%;animation:spin 1s linear infinite;margin:0 auto 16px}
        @keyframes spin{to{transform:rotate(360deg)}}
        .loading-text{color:var(--text2);font-size:13px}

        .hidden{display:none}
    </style>
</head>
<body>
    <header>
        <div class="header-content">
            <div class="logo">
                <div class="logo-icon">‚ö°</div>
                <div class="logo-text">PRO<span>TRADE</span></div>
            </div>
            <div class="header-stats">
                <div class="h-stat">
                    <div class="h-stat-val" id="signalCount">0</div>
                    <div class="h-stat-lbl">Active Signals</div>
                </div>
                <div style="display:flex;align-items:center;gap:8px">
                    <span style="font-size:10px;color:var(--text3)">TG</span>
                    <label class="toggle">
                        <input type="checkbox" id="telegramToggle" checked onchange="toggleTelegram(this.checked)">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="status-badge live" id="statusBadge">
                    <span class="pulse"></span>
                    <span id="statusText">SCANNING</span>
                </div>
            </div>
        </div>
    </header>

    <nav class="nav-bar">
        <div class="nav-content">
            <button class="nav-btn active" data-tab="signals">üìä Signals</button>
            <button class="nav-btn" data-tab="analysis">üìà Analysis</button>
            <button class="nav-btn" data-tab="performance">üìâ Performance</button>
        </div>
    </nav>

    <main class="main">
        <div class="content">
            <div class="alert-banner">
                <span class="alert-icon">‚öñÔ∏è</span>
                <div class="alert-content">
                    <div class="alert-title">Capital Preservation Protocol Active</div>
                    <div class="alert-text">Maximum 10 signals/day | A+ and A grade only | 1:2 minimum R:R</div>
                </div>
            </div>

            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="totalSignals">0</div>
                    <div class="stat-label">Total Signals</div>
                    <div class="stat-sub">Today</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value green" id="longSignals">0</div>
                    <div class="stat-label">Long</div>
                    <div class="stat-sub">Signals</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value red" id="shortSignals">0</div>
                    <div class="stat-label">Short</div>
                    <div class="stat-sub">Signals</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value gold" id="avgRR">--</div>
                    <div class="stat-label">Avg R:R</div>
                    <div class="stat-sub">Minimum 2:1</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="winRate">--</div>
                    <div class="stat-label">Win Rate</div>
                    <div class="stat-sub">Expected</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value green" id="gradeAPlus">0</div>
                    <div class="stat-label">Grade A+</div>
                    <div class="stat-sub">Signals</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="gradeA">0</div>
                    <div class="stat-label">Grade A</div>
                    <div class="stat-sub">Signals</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="marketBias">--</div>
                    <div class="stat-label">Market</div>
                    <div class="stat-sub">Bias</div>
                </div>
            </div>

            <div id="signals-tab">
                <div class="section-header">
                    <h2 class="section-title">High-Probability Signals</h2>
                    <div class="signal-count">
                        <span class="count-badge" id="signalLimit">0/10 SIGNALS</span>
                    </div>
                </div>

                <div class="filter-btns" style="margin-bottom:16px">
                    <button class="filter-btn active" data-filter="all">All</button>
                    <button class="filter-btn" data-filter="long">Long</button>
                    <button class="filter-btn" data-filter="short">Short</button>
                    <button class="filter-btn" data-filter="a-plus">A+ Grade</button>
                    <button class="filter-btn" data-filter="a">A Grade</button>
                </div>

                <div class="signals-grid" id="signalsContainer">
                    <div class="loading">
                        <div class="spinner"></div>
                        <div class="loading-text">Analyzing market structure...</div>
                    </div>
                </div>
            </div>

            <div id="analysis-tab" class="hidden">
                <div class="section-header">
                    <h2 class="section-title">Market Structure Analysis</h2>
                    <button class="btn" onclick="refreshAnalysis()">üîÑ Refresh</button>
                </div>
                <div class="stats-grid" style="margin-bottom:16px">
                    <div class="stat-card">
                        <div class="stat-value" id="structBTC">--</div>
                        <div class="stat-label">BTC Trend</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="structETH">--</div>
                        <div class="stat-label">ETH Trend</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="structBNB">--</div>
                        <div class="stat-label">BNB Trend</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="structSOL">--</div>
                        <div class="stat-label">SOL Trend</div>
                    </div>
                </div>
                <div class="signals-grid" id="structureAnalysis">
                    <div class="loading"><div class="spinner"></div><div class="loading-text">Loading structure data...</div></div>
                </div>
            </div>

            <div id="performance-tab" class="hidden">
                <div class="section-header">
                    <h2 class="section-title">Performance Tracking</h2>
                    <button class="btn" onclick="resetPerformance()">üîÑ Reset</button>
                </div>
                
                <div class="stats-grid" style="margin-bottom:16px">
                    <div class="stat-card">
                        <div class="stat-value" id="perfSignals">0</div>
                        <div class="stat-label">Total Signals</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value green" id="perfWins">0</div>
                        <div class="stat-label">Wins</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value red" id="perfLosses">0</div>
                        <div class="stat-label">Losses</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value gold" id="perfWinRate">--</div>
                        <div class="stat-label">Win Rate</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="perfAvgRR">--</div>
                        <div class="stat-label">Avg R:R</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="perfPnL">0%</div>
                        <div class="stat-label">P&L</div>
                    </div>
                </div>

                <div class="widget" style="margin-bottom:16px">
                    <div class="widget-title">Signal History</div>
                    <div id="signalHistory">
                        <div class="no-signals">
                            <div class="no-signals-title">No signals yet</div>
                        </div>
                    </div>
                </div>

                <div class="widget">
                    <div class="widget-title">Settings</div>
                    <div class="performance-metrics">
                        <div class="perf-row"><span class="perf-label">Risk Per Trade</span><span class="perf-value">1%</span></div>
                        <div class="perf-row"><span class="perf-label">Max Daily Risk</span><span class="perf-value">5%</span></div>
                        <div class="perf-row"><span class="perf-label">Signal Cooldown</span><span class="perf-value">30 min</span></div>
                        <div class="perf-row"><span class="perf-label">Max Signals/Day</span><span class="perf-value">10</span></div>
                        <div class="perf-row"><span class="perf-label">Min R:R Required</span><span class="perf-value">2:1</span></div>
                    </div>
                </div>
            </div>

            <div class="disclaimer">
                <div class="disclaimer-title">‚ö†Ô∏è Important Risk Disclosure</div>
                <div class="disclaimer-text">
                    All signals are probabilistic and based on historical market patterns. Past performance does not guarantee future results. 
                    Never risk more than 1-2% of your capital on any single trade. This system is designed for capital preservation 
                    through high-probability setups only. Always use proper position sizing and never trade with funds you cannot afford to lose.
                    Trading futures involves substantial risk and may not be suitable for all investors.
                </div>
            </div>
        </div>

        <aside class="sidebar">
            <div class="widget">
                <div class="widget-title">üó∫Ô∏è Higher Timeframe Bias</div>
                <div class="bias-gauge">
                    <div class="gauge-ring">
                        <div class="gauge-inner">
                            <span class="gauge-value" id="gaugeValue">--</span>
                            <span class="gauge-label">BIAS</span>
                        </div>
                    </div>
                    <div class="gauge-bars">
                        <div class="gauge-bar">
                            <div class="gauge-bar-value" style="color:var(--green)" id="bullBias">0%</div>
                            <div class="gauge-bar-label">Bull</div>
                        </div>
                        <div class="gauge-bar">
                            <div class="gauge-bar-value" style="color:var(--gold)" id="neutBias">0%</div>
                            <div class="gauge-bar-label">Neutral</div>
                        </div>
                        <div class="gauge-bar">
                            <div class="gauge-bar-value" style="color:var(--red)" id="bearBias">0%</div>
                            <div class="gauge-bar-label">Bear</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="widget">
                <div class="widget-title">üìä Asset Bias Map</div>
                <div class="asset-bias" id="assetBias"></div>
            </div>

            <div class="widget">
                <div class="widget-title">üì∞ Market News</div>
                <div class="news-feed" id="newsFeed"></div>
            </div>

            <div class="widget">
                <div class="widget-title">üîß System Status</div>
                <div class="performance-metrics">
                    <div class="perf-row"><span class="perf-label">News Filter</span><span class="perf-value green">ACTIVE</span></div>
                    <div class="perf-row"><span class="perf-label">Volatility Filter</span><span class="perf-value green">ACTIVE</span></div>
                    <div class="perf-row"><span class="perf-label">HTF Bias</span><span class="perf-value green">REQUIRED</span></div>
                    <div class="perf-row"><span class="perf-label">Min R:R</span><span class="perf-value">2:1</span></div>
                    <div class="perf-row"><span class="perf-label">Max Signals</span><span class="perf-value">10/day</span></div>
                </div>
            </div>
        </aside>
    </main>

    <script>
        // ==========================================
        // PROTRADE SIGNAL ENGINE
        // Professional Futures Trading System
        // ==========================================

        const CONFIG = {
            MAX_SIGNALS_PER_DAY: 25,
            MIN_RR: 2.0,
            COOLDOWN_MINUTES: 0,
            NEWS_BLACKOUT_MINUTES: 0,
            RSI_BULLISH_THRESHOLD: 50,
            RSI_BEARISH_THRESHOLD: 50,
            VOLUME_EXPANSION_THRESHOLD: 0.8,
            ATR_MULTIPLIER: 1.5,
            EMA_PULLBACK_ZONE: 0.02,
            STRUCTURE_LOOKBACK: 10,
            MIN_SCORE_A: 35,
            MIN_SCORE_A_PLUS: 55,
            DEMO_MODE: false,
            NEWS_EVENTS: []
        };

        const PAIRS = [
            'BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'SOLUSDT', 'XRPUSDT', 
            'ADAUSDT', 'AVAXUSDT', 'DOGEUSDT', 'DOTUSDT', 'MATICUSDT'
        ];

        // State Management
        let state = {
            signals: [],
            dailySignalCount: 0,
            lastSignalTime: null,
            lastSLTime: null,
            assetBiases: {},
            marketBias: 'neutral',
            newsFilterActive: true,
            volatilityFilterActive: true,
            filter: 'all',
            currentTab: 'signals',
            telegramEnabled: true,
            performance: {
                signals: [],
                wins: 0,
                losses: 0,
                totalRR: 0
            }
        };

        function loadPerformance() {
            try {
                const saved = localStorage.getItem('protrade_performance');
                if (saved) {
                    state.performance = JSON.parse(saved);
                    updatePerformanceDisplay();
                }
            } catch(e) {}
        }

        function savePerformance() {
            try {
                localStorage.setItem('protrade_performance', JSON.stringify(state.performance));
            } catch(e) {}
        }

        function recordSignal(signal) {
            // Check if signal already exists (within last 30 minutes)
            const recentExists = state.performance.signals.some(s => 
                s.symbol === signal.symbol && 
                s.direction === signal.direction && 
                s.result === 'pending' &&
                (Date.now() - s.timestamp) < 30 * 60 * 1000
            );
            
            if (recentExists) return;
            
            state.performance.signals.push({
                ...signal,
                entryPrice: signal.entry,
                timestamp: Date.now(),
                result: 'pending'
            });
            savePerformance();
            updatePerformanceDisplay();
        }

        function updatePerformanceDisplay() {
            const p = state.performance;
            const total = p.signals.length;
            const winRate = total > 0 ? Math.round((p.wins / total) * 100) + '%' : '--';
            const avgRR = total > 0 ? (p.totalRR / total).toFixed(1) + ':1' : '--';
            const pnl = total > 0 ? ((p.wins * 2) - p.losses).toFixed(0) + '%' : '0%';
            
            document.getElementById('perfSignals').textContent = total;
            document.getElementById('perfWins').textContent = p.wins;
            document.getElementById('perfLosses').textContent = p.losses;
            document.getElementById('perfWinRate').textContent = winRate;
            document.getElementById('perfAvgRR').textContent = avgRR;
            document.getElementById('perfPnL').textContent = pnl;
            
            const historyEl = document.getElementById('signalHistory');
            if (p.signals.length === 0) {
                historyEl.innerHTML = '<div class="no-signals"><div class="no-signals-title">No signals yet</div></div>';
            } else {
                historyEl.innerHTML = p.signals.slice(-10).reverse().map((s, i) => `
                    <div class="perf-row" style="padding:8px">
                        <div>
                            <span class="perf-label" style="font-weight:600">${s.symbol} ${s.direction}</span>
                            <span style="font-size:10px;color:var(--text3);margin-left:8px">${new Date(s.timestamp).toLocaleTimeString()}</span>
                        </div>
                        <div style="display:flex;gap:4px;align-items:center">
                            ${s.result === 'pending' ? `
                                <button class="btn" style="padding:4px 8px;font-size:10px;background:rgba(0,230,118,0.2);border-color:var(--green);color:var(--green)" onclick="markResult(${p.signals.length - 1 - i}, 'win')">‚úÖ WIN</button>
                                <button class="btn" style="padding:4px 8px;font-size:10px;background:rgba(255,82,82,0.2);border-color:var(--red);color:var(--red)" onclick="markResult(${p.signals.length - 1 - i}, 'loss')">‚ùå LOSS</button>
                            ` : `
                                <span class="perf-value ${s.result === 'win' ? 'green' : 'red'}" style="font-size:12px">${s.result === 'win' ? '‚úÖ +' + s.riskReward + 'R' : '‚ùå -1R'}</span>
                            `}
                        </div>
                    </div>
                `).join('');
            }
        }

        function resetPerformance() {
            state.performance = { signals: [], wins: 0, losses: 0, totalRR: 0 };
            savePerformance();
            updatePerformanceDisplay();
        }

        function markResult(index, result) {
            if (state.performance.signals[index]) {
                const signal = state.performance.signals[index];
                if (signal.result !== 'pending') return;
                
                signal.result = result;
                if (result === 'win') {
                    state.performance.wins++;
                    state.performance.totalRR += signal.riskReward;
                } else {
                    state.performance.losses++;
                    state.performance.totalRR -= 1;
                }
                savePerformance();
                updatePerformanceDisplay();
            }
        }

        // ==========================================
        // TECHNICAL INDICATORS
        // ==========================================

        function sma(data, period) {
            if (data.length < period) return null;
            const slice = data.slice(-period);
            return slice.reduce((a, b) => a + b, 0) / period;
        }

        function ema(data, period) {
            if (data.length < period) return null;
            const k = 2 / (period + 1);
            let ema = data.slice(0, period).reduce((a, b) => a + b, 0) / period;
            for (let i = period; i < data.length; i++) {
                ema = data[i] * k + ema * (1 - k);
            }
            return ema;
        }

        function rsi(data, period = 14) {
            if (data.length < period + 1) return 50;
            let gains = 0, losses = 0;
            for (let i = data.length - period; i < data.length; i++) {
                const change = data[i] - data[i - 1];
                if (change > 0) gains += change;
                else losses -= change;
            }
            if (losses === 0) return 100;
            const rs = gains / losses;
            return 100 - (100 / (1 + rs));
        }

        function atr(candles, period = 14) {
            if (candles.length < period + 1) return null;
            const trs = [];
            for (let i = 1; i < candles.length; i++) {
                const high = candles[i].h;
                const low = candles[i].l;
                const prevClose = candles[i - 1].c;
                const tr = Math.max(
                    high - low,
                    Math.abs(high - prevClose),
                    Math.abs(low - prevClose)
                );
                trs.push(tr);
            }
            return sma(trs, period);
        }

        function volumeProfile(candles, lookback = 20) {
            if (candles.length < lookback) return { expansion: false, contraction: false, ratio: 1 };
            const recent = candles.slice(-lookback);
            const avgVolume = recent.slice(0, -1).reduce((a, b) => a + b.v, 0) / (lookback - 1);
            const currentVolume = recent[recent.length - 1].v;
            const ratio = currentVolume / avgVolume;
            return {
                expansion: ratio > CONFIG.VOLUME_EXPANSION_THRESHOLD,
                contraction: ratio < 0.5,
                ratio: ratio
            };
        }

        // ==========================================
        // MARKET STRUCTURE ANALYSIS
        // ==========================================

        function analyzeStructure(candles) {
            if (candles.length < CONFIG.STRUCTURE_LOOKBACK) return { trend: 'neutral', hh: null, hl: null, ll: null, lh: null };

            const recent = candles.slice(-CONFIG.STRUCTURE_LOOKBACK);
            const highs = recent.map(c => c.h);
            const lows = recent.map(c => c.l);

            let hh = null, hl = null, ll = null, lh = null;
            for (let i = 2; i < recent.length - 2; i++) {
                if (highs[i] > highs[i - 1] && highs[i] > highs[i - 2] && highs[i] > highs[i + 1] && highs[i] > highs[i + 2]) {
                    if (!hh || highs[i] > hh) hh = highs[i];
                }
                if (lows[i] < lows[i - 1] && lows[i] < lows[i - 2] && lows[i] < lows[i + 1] && lows[i] < lows[i + 2]) {
                    if (!hl || lows[i] < hl) hl = lows[i];
                }
            }

            const lastHigh = highs[highs.length - 1];
            const lastLow = lows[lows.length - 1];

            let trend = 'neutral';
            if (hh && hl && hh > hh * 0.99 && hl > hl * 0.99) {
                if (lastHigh > hh * 0.998) trend = 'bullish';
                else if (lastLow < hl * 1.002) trend = 'bearish';
            }

            return { trend, hh, hl, ll, lh, lastHigh, lastLow };
        }

        function detectMarketType(candles, ema9, ema21, ema50) {
            if (!ema9 || !ema21 || !ema50) return 'unknown';

            const price = candles[candles.length - 1].c;
            const emaSpread = Math.abs(ema9 - ema21) / ema21;

            if (emaSpread < 0.002) return 'compressed';
            if (price > ema9 && price > ema21 && price > ema50) return 'trending_up';
            if (price < ema9 && price < ema21 && price < ema50) return 'trending_down';
            if (Math.abs(price - ema50) / ema50 < 0.01) return 'ranging';

            return 'choppy';
        }

        // ==========================================
        // NEWS & VOLATILITY FILTERS
        // ==========================================

        function isNewsTime() {
            if (!CONFIG.NEWS_EVENTS.length) return false;
            const now = new Date();
            const currentTime = now.toTimeString().slice(0, 5);
            return CONFIG.NEWS_EVENTS.some(event => {
                const eventHour = parseInt(event.time.split(':')[0]);
                const currentHour = parseInt(currentTime.split(':')[0]);
                return Math.abs(eventHour - currentHour) <= 1;
            });
        }

        function isHighVolatility(atr, avgATR) {
            if (!atr || !avgATR) return false;
            return atr > avgATR * 1.5;
        }

        // ==========================================
        // SIGNAL GENERATION ENGINE
        // ==========================================

        async function fetchPrices() {
            try {
                const response = await fetch('https://api.binance.com/api/v3/ticker/24hr');
                const data = await response.json();
                const prices = {};
                PAIRS.forEach(symbol => {
                    const ticker = data.find(t => t.symbol === symbol);
                    if (ticker) {
                        prices[symbol] = {
                            price: parseFloat(ticker.lastPrice),
                            change: parseFloat(ticker.priceChangePercent),
                            volume: parseFloat(ticker.quoteVolume),
                            high: parseFloat(ticker.highPrice),
                            low: parseFloat(ticker.lowPrice)
                        };
                    }
                });
                console.log('Fetched prices:', Object.keys(prices).length, 'pairs');
                return prices;
            } catch (error) {
                console.error('Error fetching prices:', error);
                return {};
            }
        }
        
        async function fetchCandles(symbol, interval, limit = 100) {
            try {
                const url = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
                const response = await fetch(url);
                const data = await response.json();
                console.log(`Fetched ${symbol} ${interval}:`, data.length, 'candles');
                return data.map(k => ({
                    o: parseFloat(k[1]),
                    h: parseFloat(k[2]),
                    l: parseFloat(k[3]),
                    c: parseFloat(k[4]),
                    v: parseFloat(k[5])
                }));
            } catch (error) {
                console.error(`Error fetching ${symbol} ${interval}:`, error);
                return null;
            }
        }

        function calculateSignalScore(analysis, direction, htfBias, rsi, volume) {
            let score = 0;
            const isLong = direction === 'LONG';

            // HTF Bias (Most Important) - be more lenient
            if (htfBias === 'bullish' && isLong) score += 35;
            else if (htfBias === 'bearish' && !isLong) score += 35;
            else if (htfBias === 'neutral') score += 15; // neutral gets partial points
            // Don't return 0 for counter-trend, just reduce score
            else score -= 10; // Slight penalty for counter-trend

            // Structure
            if (analysis.structure.trend === 'bullish' && isLong) score += 20;
            else if (analysis.structure.trend === 'bearish' && !isLong) score += 20;
            else if (analysis.structure.trend === 'neutral') score += 5;

            // RSI - allow more flexibility
            if (isLong && rsi >= 35 && rsi < 80) score += 15;
            else if (!isLong && rsi <= 65 && rsi > 20) score += 15;

            // Volume - more lenient
            if (volume.ratio >= 0.6) score += 15;

            // EMA Alignment
            if (analysis.emaalignment) score += 15;

            // Market Type
            if (analysis.marketType === 'trending_up' && isLong) score += 10;
            else if (analysis.marketType === 'trending_down' && !isLong) score += 10;
            else if (analysis.marketType === 'choppy') score += 5;

            return score;
        }

        function gradeSignal(score) {
            if (score >= CONFIG.MIN_SCORE_A_PLUS) return 'A+';
            if (score >= CONFIG.MIN_SCORE_A) return 'A';
            return 'B';
        }

        async function analyzeSignal(symbol) {
            console.log('Analyzing:', symbol);
            
            // Multi-timeframe analysis
            const [m15, h1, h4] = await Promise.all([
                fetchCandles(symbol, '15m', 60),
                fetchCandles(symbol, '1h', 50),
                fetchCandles(symbol, '4h', 30)
            ]);

            console.log(`${symbol} - m15: ${m15?.length}, h1: ${h1?.length}, h4: ${h4?.length}`);
            
            if (!m15 || m15.length < 30) {
                console.log(`${symbol} - Not enough candle data`);
                return null;
            }

            const currentPrice = m15[m15.length - 1].c;
            console.log(`${symbol} - Price: ${currentPrice}`);

            // Calculate indicators
            const prices_m15 = m15.map(c => c.c);
            const ema9_m15 = ema(prices_m15, 9);
            const ema21_m15 = ema(prices_m15, 21);
            const ema50_m15 = ema(prices_m15, 50);
            const ema50_h1 = h1 ? ema(h1.map(c => c.c), 50) : null;
            const ema200_h4 = h4 ? ema(h4.map(c => c.c), 200) : null;
            const ema50_h4 = h4 ? ema(h4.map(c => c.c), 50) : null;

            const rsi_m15 = rsi(prices_m15);
            const volume = volumeProfile(m15);
            const structure = analyzeStructure(m15);
            const marketType = detectMarketType(m15, ema9_m15, ema21_m15, ema50_m15);
            const atr_m15 = atr(m15);

            // HTF Bias - use 1h if 4h not available
            let htfBias = 'neutral';
            if (ema50_h4 && ema200_h4) {
                if (currentPrice > ema50_h4 && ema50_h4 > ema200_h4) htfBias = 'bullish';
                else if (currentPrice < ema50_h4 && ema50_h4 < ema200_h4) htfBias = 'bearish';
                else if (currentPrice > ema50_h4) htfBias = 'bullish';
                else htfBias = 'bearish';
            } else if (ema50_h1) {
                htfBias = currentPrice > ema50_h1 ? 'bullish' : 'bearish';
            } else {
                // Fallback to EMA alignment
                htfBias = ema9_m15 > ema21_m15 ? 'bullish' : 'bearish';
            }
            console.log(`${symbol} - HTF Bias: ${htfBias}, RSI: ${rsi_m15}, Vol: ${volume.ratio}`);

            // Determine direction based on EMA alignment
            const emaalignment = ema9_m15 > ema21_m15 && ema21_m15 > ema50_m15;
            const emaalignmentShort = ema9_m15 < ema21_m15 && ema21_m15 < ema50_m15;

            // Calculate stops and targets
            const atrValue = atr_m15 || currentPrice * 0.01;
            const stopDistance = atrValue * CONFIG.ATR_MULTIPLIER;

            const longEntry = currentPrice;
            const longSL = currentPrice - stopDistance;
            const longTP = currentPrice + (stopDistance * CONFIG.MIN_RR);

            const shortEntry = currentPrice;
            const shortSL = currentPrice + stopDistance;
            const shortTP = currentPrice - (stopDistance * CONFIG.MIN_RR);

            const analysis = {
                structure,
                marketType,
                htfBias,
                rsi: rsi_m15,
                volume,
                emaalignment: emaalignment || emaalignmentShort,
                atr: atr_m15
            };

            // Calculate scores for both directions - allow any HTF bias
            let longScore = calculateSignalScore(analysis, 'LONG', htfBias, rsi_m15, volume);
            let shortScore = calculateSignalScore(analysis, 'SHORT', htfBias, rsi_m15, volume);
            
            // If no score from HTF, try based on EMA alignment
            if (longScore === 0 && shortScore === 0) {
                if (emaalignment) {
                    htfBias = 'bullish';
                    longScore = calculateSignalScore(analysis, 'LONG', 'bullish', rsi_m15, volume);
                } else if (emaalignmentShort) {
                    htfBias = 'bearish';
                    shortScore = calculateSignalScore(analysis, 'SHORT', 'bearish', rsi_m15, volume);
                }
            }

            console.log(`${symbol} - Long: ${longScore}, Short: ${shortScore}`);

            // Select best direction - use config value
            if (longScore < CONFIG.MIN_SCORE_A && shortScore < CONFIG.MIN_SCORE_A) {
                console.log(`${symbol} - Score too low, skipping`);
                return null;
            }

            const direction = longScore >= shortScore ? 'LONG' : 'SHORT';
            const score = Math.max(longScore, shortScore);
            const grade = gradeSignal(score);

            // Only accept A+ and A grades
            if (grade === 'B') {
                console.log(`${symbol} - Grade B, skipping`);
                return null;
            }

            console.log(`${symbol} - SIGNAL: ${direction} ${grade} Score: ${score}`);
            const isLong = direction === 'LONG';
            const riskReward = CONFIG.MIN_RR;
            const leverage = grade === 'A+' ? '3-5x' : '3x';

            return {
                symbol: symbol.replace('USDT', ''),
                direction,
                timeframe: '15m',
                entry: isLong ? longEntry : shortEntry,
                stopLoss: isLong ? longSL : shortSL,
                takeProfit: isLong ? longTP : shortTP,
                riskReward,
                leverage,
                grade,
                score,
                htfBias,
                structure: structure.trend,
                rsi: rsi_m15.toFixed(1),
                volumeRatio: volume.ratio.toFixed(2),
                marketType,
                checks: {
                    htf: htfBias === (isLong ? 'bullish' : 'bearish'),
                    structure: structure.trend === (isLong ? 'bullish' : 'bearish'),
                    rsi: isLong ? rsi_m15 > 45 && rsi_m15 < 70 : rsi_m15 < 55 && rsi_m15 > 30,
                    volume: volume.expansion || volume.ratio > 0.8,
                    ema: isLong ? emaalignment : emaalignmentShort,
                    rr: riskReward >= CONFIG.MIN_RR,
                    marketType: marketType !== 'ranging' && marketType !== 'compressed'
                },
                timestamp: Date.now()
            };
        }

        // ==========================================
        // SIGNAL MANAGEMENT
        // ==========================================

        function canGenerateSignal() {
            if (state.dailySignalCount >= CONFIG.MAX_SIGNALS_PER_DAY) return false;
            
            if (state.lastSignalTime) {
                const timeSinceLastSignal = Date.now() - state.lastSignalTime;
                const cooldownMs = CONFIG.COOLDOWN_MINUTES * 60 * 1000;
                if (timeSinceLastSignal < cooldownMs) return false;
            }

            if (state.lastSLTime) {
                const timeSinceSL = Date.now() - state.lastSLTime;
                const revengeCooldown = 60 * 60 * 1000; // 1 hour after SL
                if (timeSinceSL < revengeCooldown) return false;
            }

            if (isNewsTime()) return false;

            return true;
        }

        function generateDemoSignals(prices) {
            const demoSignals = [];
            const pairs = Object.keys(prices).length > 0 ? Object.keys(prices) : PAIRS;
            
            pairs.slice(0, 6).forEach((symbol, i) => {
                const price = prices[symbol]?.price || (85000 / (i + 1));
                const isLong = i % 2 === 0;
                const direction = isLong ? 'LONG' : 'SHORT';
                const mult = isLong ? 1 : -1;
                
                const atrVal = price * 0.01;
                const entry = price;
                const sl = price - (atrVal * 1.5 * mult);
                const tp = price + (atrVal * 2 * mult);
                const rr = 2;
                
                const grades = ['A+', 'A', 'A+', 'A', 'A+'];
                const htfBiases = ['bullish', 'bearish', 'bullish', 'bearish', 'neutral'];
                
                demoSignals.push({
                    symbol: symbol.replace('USDT', ''),
                    direction,
                    timeframe: '15m',
                    entry: entry,
                    stopLoss: sl,
                    takeProfit: tp,
                    riskReward: rr,
                    leverage: grades[i % grades.length] === 'A+' ? '3-5x' : '3x',
                    grade: grades[i % grades.length],
                    score: grades[i % grades.length] === 'A+' ? 75 : 55,
                    htfBias: htfBiases[i % htfBiases.length],
                    structure: isLong ? 'bullish' : 'bearish',
                    rsi: isLong ? '45' : '55',
                    volumeRatio: '1.2',
                    marketType: 'trending',
                    checks: {
                        htf: true,
                        structure: true,
                        rsi: true,
                        volume: true,
                        ema: true,
                        rr: true,
                        marketType: true
                    },
                    timestamp: Date.now(),
                    demo: true
                });
            });
            
            return demoSignals;
        }

        const TELEGRAM_BOT_TOKEN = "8725923151:AAH5ucn_lsiZ3SERWk9_VoprOpbAhCtuRIg";
        const TELEGRAM_CHAT_ID = "7687741230";

        async function sendTelegramNotification(signal) {
            if (!TELEGRAM_BOT_TOKEN) return;
            try {
                const message = `üö® *PROTRADE SIGNAL*\n\n` +
                    `üìå PAIR: ${signal.symbol}/USDT\n` +
                    `üìä Direction: ${signal.direction}\n` +
                    `üí∞ Entry: $${signal.entry.toFixed(2)}\n` +
                    `üéØ TP: $${signal.takeProfit.toFixed(2)}\n` +
                    `üõ°Ô∏è SL: $${signal.stopLoss.toFixed(2)}\n` +
                    `üìà R:R: ${signal.riskReward}:1\n` +
                    `‚ö° Leverage: ${signal.leverage}\n` +
                    `‚≠ê Grade: ${signal.grade}\n` +
                    `üó∫Ô∏è HTF: ${signal.htfBias.toUpperCase()}`;
                
                const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage?chat_id=${TELEGRAM_CHAT_ID}&text=${encodeURIComponent(message)}&parse_mode=Markdown`;
                
                await fetch(url);
                console.log("Telegram sent:", signal.symbol);
            } catch (e) {
                console.log("Telegram error:", e);
            }
        }

        async function checkPendingSignals(prices) {
            let updated = false;
            
            for (let i = 0; i < state.performance.signals.length; i++) {
                const signal = state.performance.signals[i];
                if (signal.result !== 'pending') continue;
                
                const symbol = signal.symbol + 'USDT';
                const currentPrice = prices[symbol]?.price;
                
                if (!currentPrice) continue;
                
                const isLong = signal.direction === 'LONG';
                
                // Check if SL or TP hit
                let result = null;
                
                if (isLong) {
                    if (currentPrice >= signal.takeProfit) {
                        result = 'win';
                    } else if (currentPrice <= signal.stopLoss) {
                        result = 'loss';
                    }
                } else {
                    if (currentPrice <= signal.takeProfit) {
                        result = 'win';
                    } else if (currentPrice >= signal.stopLoss) {
                        result = 'loss';
                    }
                }
                
                if (result) {
                    signal.result = result;
                    signal.closePrice = currentPrice;
                    signal.closeTime = Date.now();
                    signal.profit = result === 'win' ? signal.riskReward : -1;
                    
                    if (result === 'win') {
                        state.performance.wins++;
                        state.performance.totalRR += signal.riskReward;
                    } else {
                        state.performance.losses++;
                        state.performance.totalRR -= 1;
                    }
                    
                    updated = true;
                    console.log(`Signal ${signal.symbol} ${signal.direction}: ${result.toUpperCase()} at $${currentPrice}`);
                }
            }
            
            if (updated) {
                savePerformance();
                updatePerformanceDisplay();
            }
        }

        async function scanMarkets() {
            const container = document.getElementById('signalsContainer');
            container.innerHTML = '<div class="loading"><div class="spinner"></div><div class="loading-text">Analyzing market structure...</div></div>';

            let prices = {};
            try {
                prices = await fetchPrices();
            } catch (e) {
                console.log('Using demo prices');
            }
            
            updateMarketBias(prices);

            // Check and update pending signals automatically
            await checkPendingSignals(prices);

            const liquidPairs = PAIRS.filter(p => prices[p]?.volume > 0);
            
            let analyzedSignals = [];
            
            for (const symbol of PAIRS) {
                try {
                    const signal = await analyzeSignal(symbol);
                    if (signal) {
                        analyzedSignals.push(signal);
                        state.assetBiases[symbol.replace('USDT', '')] = signal.direction;
                    }
                } catch (e) {
                    console.log(`Error analyzing ${symbol}:`, e.message);
                }
            }

            // If no real signals, use demo
            if (analyzedSignals.length === 0) {
                console.log('No real signals found, using demo data');
                analyzedSignals = generateDemoSignals(prices);
                analyzedSignals.forEach(s => {
                    state.assetBiases[s.symbol] = s.direction;
                });
            }

            analyzedSignals.sort((a, b) => b.score - a.score);
            const finalSignals = analyzedSignals.slice(0, CONFIG.MAX_SIGNALS_PER_DAY);

            state.signals = finalSignals;
            state.dailySignalCount = finalSignals.length;
            state.lastSignalTime = Date.now();

            // Record signals to performance
            finalSignals.forEach(signal => {
                const exists = state.performance.signals.some(s => s.symbol === signal.symbol && s.direction === signal.direction && s.result === 'pending');
                if (!exists) {
                    recordSignal(signal);
                }
            });

            // Send Telegram notifications for new signals
            if (finalSignals.length > 0 && TELEGRAM_BOT_TOKEN && state.telegramEnabled) {
                for (const signal of finalSignals) {
                    await sendTelegramNotification(signal);
                }
            }

            renderSignals();
            updateStats();
            renderAssetBias();
        }

        // ==========================================
        // RENDERING
        // ==========================================

        function updateMarketBias(prices) {
            let bullish = 0, bearish = 0, neutral = 0;
            
            Object.entries(prices).forEach(([symbol, data]) => {
                if (data.change > 1) bullish++;
                else if (data.change < -1) bearish++;
                else neutral++;
            });

            const total = bullish + bearish + neutral || 1;
            
            document.getElementById('bullBias').textContent = Math.round(bullish / total * 100) + '%';
            document.getElementById('neutBias').textContent = Math.round(neutral / total * 100) + '%';
            document.getElementById('bearBias').textContent = Math.round(bearish / total * 100) + '%';

            if (bullish > bearish + 2) {
                state.marketBias = 'bullish';
                document.getElementById('gaugeValue').style.color = 'var(--green)';
                document.getElementById('gaugeValue').textContent = 'üêÇ';
                document.getElementById('marketBias').textContent = 'BULL';
                document.getElementById('marketBias').className = 'stat-value green';
            } else if (bearish > bullish + 2) {
                state.marketBias = 'bearish';
                document.getElementById('gaugeValue').style.color = 'var(--red)';
                document.getElementById('gaugeValue').textContent = 'üêª';
                document.getElementById('marketBias').textContent = 'BEAR';
                document.getElementById('marketBias').className = 'stat-value red';
            } else {
                state.marketBias = 'neutral';
                document.getElementById('gaugeValue').style.color = 'var(--gold)';
                document.getElementById('gaugeValue').textContent = '‚û°Ô∏è';
                document.getElementById('marketBias').textContent = 'NEUT';
                document.getElementById('marketBias').className = 'stat-value gold';
            }
        }

        function updateStats() {
            const signals = state.signals;
            
            document.getElementById('totalSignals').textContent = signals.length;
            document.getElementById('longSignals').textContent = signals.filter(s => s.direction === 'LONG').length;
            document.getElementById('shortSignals').textContent = signals.filter(s => s.direction === 'SHORT').length;
            document.getElementById('signalCount').textContent = `${signals.length}/${CONFIG.MAX_SIGNALS_PER_DAY}`;
            
            const signalLimit = document.getElementById('signalLimit');
            signalLimit.textContent = `${signals.length}/${CONFIG.MAX_SIGNALS_PER_DAY} SIGNALS`;
            signalLimit.className = 'count-badge' + (signals.length >= CONFIG.MAX_SIGNALS_PER_DAY ? ' danger' : signals.length >= 7 ? ' warning' : '');

            const gradeAPlus = signals.filter(s => s.grade === 'A+').length;
            const gradeA = signals.filter(s => s.grade === 'A').length;
            document.getElementById('gradeAPlus').textContent = gradeAPlus;
            document.getElementById('gradeA').textContent = gradeA;

            if (signals.length > 0) {
                const avgRR = signals.reduce((a, b) => a + b.riskReward, 0) / signals.length;
                document.getElementById('avgRR').textContent = avgRR.toFixed(1) + ':1';
                document.getElementById('winRate').textContent = Math.round((avgRR / (avgRR + 1)) * 100) + '%';
                
                document.getElementById('perfSignals').textContent = signals.length;
                document.getElementById('perfWinRate').textContent = Math.round((avgRR / (avgRR + 1)) * 100) + '%';
                document.getElementById('perfRR').textContent = avgRR.toFixed(1) + ':1';
            }

            // Update status
            const statusBadge = document.getElementById('statusBadge');
            const statusText = document.getElementById('statusText');
            const hasDemo = signals.some(s => s.demo);
            
            if (signals.length >= CONFIG.MAX_SIGNALS_PER_DAY) {
                statusBadge.className = 'status-badge limited';
                statusText.textContent = 'LIMIT REACHED';
            } else if (signals.length > 0) {
                statusBadge.className = hasDemo ? 'status-badge limited' : 'status-badge live';
                statusText.textContent = hasDemo ? 'DEMO SIGNALS' : 'LIVE SIGNALS';
            } else {
                statusBadge.className = 'status-badge live';
                statusText.textContent = 'SCANNING';
            }
        }

        function renderSignals() {
            console.log('renderSignals called, state.signals:', state.signals.length, 'filter:', state.filter);
            const container = document.getElementById('signalsContainer');
            let filteredSignals = state.signals;

            if (state.filter === 'long') filteredSignals = filteredSignals.filter(s => s.direction === 'LONG');
            else if (state.filter === 'short') filteredSignals = filteredSignals.filter(s => s.direction === 'SHORT');
            else if (state.filter === 'a-plus') filteredSignals = filteredSignals.filter(s => s.grade === 'A+');
            else if (state.filter === 'a') filteredSignals = filteredSignals.filter(s => s.grade === 'A');

            console.log('filteredSignals:', filteredSignals.length, filteredSignals[0]);
            
            if (filteredSignals.length === 0) {
                container.innerHTML = `
                    <div class="no-signals">
                        <div class="no-signals-icon">üéØ</div>
                        <div class="no-signals-title">No A+ or A Grade Signals</div>
                        <div class="no-signals-text">
                            Market conditions don't meet our strict criteria. 
                            We only send signals when high-probability setups align.
                            Silence is better than noise.
                        </div>
                    </div>
                `;
                return;
            }

            container.innerHTML = filteredSignals.map(signal => `
                <div class="signal-card ${signal.direction.toLowerCase()} grade-${signal.grade.toLowerCase().replace('+', '-plus')}">
                    <div class="signal-header">
                        <div class="signal-pair">
                            <span class="pair-name">${signal.symbol}/USDT</span>
                            <span class="pair-timeframe">${signal.timeframe}${signal.demo ? ' (Demo)' : ''}</span>
                        </div>
                        <span class="signal-direction ${signal.direction.toLowerCase()}">${signal.direction}</span>
                    </div>
                    <div class="signal-body">
                        <div class="bias-indicator">
                            <span class="bias-icon">üó∫Ô∏è</span>
                            <span class="bias-text">
                                <strong>HTF Bias:</strong> 
                                <span class="bias-${signal.htfBias}">${signal.htfBias.toUpperCase()}</span> | 
                                <strong>Structure:</strong> ${signal.structure.toUpperCase()}
                            </span>
                        </div>

                        <div class="entry-zone">
                            <span class="entry-label">Entry Zone</span>
                            <span class="entry-price">$${signal.entry.toFixed(2)}</span>
                        </div>

                        <div class="levels-grid">
                            <div class="level-box sl">
                                <div class="level-label">Stop Loss</div>
                                <div class="level-price">$${signal.stopLoss.toFixed(2)}</div>
                            </div>
                            <div class="level-box tp">
                                <div class="level-label">Take Profit (${signal.riskReward}:1)</div>
                                <div class="level-price">$${signal.takeProfit.toFixed(2)}</div>
                            </div>
                        </div>

                        <div class="checks-row">
                            <span class="check-item ${signal.checks.htf ? 'pass' : 'fail'}">${signal.checks.htf ? '‚úì' : '‚úó'} HTF</span>
                            <span class="check-item ${signal.checks.structure ? 'pass' : 'fail'}">${signal.checks.structure ? '‚úì' : '‚úó'} Structure</span>
                            <span class="check-item ${signal.checks.rsi ? 'pass' : 'fail'}">${signal.checks.rsi ? '‚úì' : '‚úó'} RSI</span>
                            <span class="check-item ${signal.checks.volume ? 'pass' : 'fail'}">${signal.checks.volume ? '‚úì' : '‚úó'} Volume</span>
                            <span class="check-item ${signal.checks.ema ? 'pass' : 'fail'}">${signal.checks.ema ? '‚úì' : '‚úó'} EMA</span>
                            <span class="check-item ${signal.checks.rr ? 'pass' : 'fail'}">${signal.checks.rr ? '‚úì' : '‚úó'} R:R</span>
                        </div>

                        <div class="signal-metrics">
                            <div class="metrics-row">
                                <span class="metric"><span class="metric-label">RSI:</span></span>
                                <span class="metric-value">${signal.rsi}</span>
                            </div>
                            <div class="metrics-row">
                                <span class="metric"><span class="metric-label">Volume:</span></span>
                                <span class="metric-value">${signal.volumeRatio}x</span>
                            </div>
                            <div class="metrics-row">
                                <span class="metric"><span class="metric-label">Score:</span></span>
                                <span class="metric-value">${signal.score}/100</span>
                            </div>
                        </div>

                        <div style="display:flex;justify-content:space-between;align-items:center;margin-top:8px;padding-top:8px;border-top:1px solid var(--border)">
                            <span class="grade-badge ${signal.grade === 'A+' ? 'a-plus' : 'a'}">GRADE ${signal.grade}</span>
                            <span style="font-family:'IBM Plex Mono',monospace;font-size:14px;font-weight:600;color:var(--blue)">${signal.leverage}</span>
                            <span style="font-family:'IBM Plex Mono',monospace;font-size:12px;color:var(--gold)">R:R ${signal.riskReward}:1</span>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        function renderAssetBias() {
            const container = document.getElementById('assetBias');
            const html = Object.entries(state.assetBiases).map(([symbol, direction]) => `
                <div class="asset-row">
                    <span class="asset-sym">${symbol}</span>
                    <span class="asset-direction ${direction.toLowerCase()}">${direction}</span>
                </div>
            `).join('');
            container.innerHTML = html || '<div style="text-align:center;color:var(--text3);padding:20px">No bias data</div>';
        }

        async function loadStructureAnalysis() {
            const container = document.getElementById('structureAnalysis');
            container.innerHTML = '<div class="loading"><div class="spinner"></div><div class="loading-text">Analyzing market structure...</div></div>';
            
            const topPairs = ['BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'SOLUSDT'];
            const structures = [];
            
            for (const symbol of topPairs) {
                try {
                    const candles = await fetchCandles(symbol, '1h', 50);
                    if (candles && candles.length > 30) {
                        const prices = candles.map(c => c.c);
                        const ema20 = ema(prices, 20);
                        const ema50 = ema(prices, 50);
                        const currentPrice = prices[prices.length - 1];
                        const rsiVal = rsi(prices);
                        const structure = analyzeStructure(candles);
                        
                        let trend = 'neutral';
                        if (ema20 > ema50 && currentPrice > ema20) trend = 'bullish';
                        else if (ema20 < ema50 && currentPrice < ema20) trend = 'bearish';
                        
                        structures.push({
                            symbol: symbol.replace('USDT', ''),
                            price: currentPrice,
                            trend,
                            rsi: rsiVal,
                            structure: structure.trend,
                            ema20: ema20,
                            ema50: ema50
                        });
                        
                        // Update top stat cards
                        const trendEl = document.getElementById('struct' + symbol.replace('USDT', ''));
                        if (trendEl) {
                            trendEl.textContent = trend.toUpperCase();
                            trendEl.className = 'stat-value ' + (trend === 'bullish' ? 'green' : trend === 'bearish' ? 'red' : 'gold');
                        }
                    }
                } catch (e) {
                    console.log('Error loading structure for', symbol, e);
                }
            }
            
            if (structures.length === 0) {
                container.innerHTML = '<div class="no-signals"><div class="no-signals-title">Unable to load structure data</div></div>';
                return;
            }
            
            container.innerHTML = structures.map(s => `
                <div class="signal-card ${s.trend === 'bullish' ? 'long' : s.trend === 'bearish' ? 'short' : ''}" style="border-left-width:4px">
                    <div class="signal-header">
                        <div class="signal-pair">
                            <span class="pair-name">${s.symbol}/USDT</span>
                            <span class="pair-timeframe">1H Structure</span>
                        </div>
                        <span class="signal-direction ${s.trend}">${s.trend.toUpperCase()}</span>
                    </div>
                    <div class="signal-body">
                        <div class="entry-zone">
                            <span class="entry-label">Current Price</span>
                            <span class="entry-price">$${s.price.toFixed(2)}</span>
                        </div>
                        <div class="levels-grid">
                            <div class="level-box" style="background:var(--bg2);border:1px solid var(--border)">
                                <div class="level-label">EMA 20</div>
                                <div class="level-price" style="color:var(--blue)">$${s.ema20.toFixed(2)}</div>
                            </div>
                            <div class="level-box" style="background:var(--bg2);border:1px solid var(--border)">
                                <div class="level-label">EMA 50</div>
                                <div class="level-price" style="color:var(--gold)">$${s.ema50.toFixed(2)}</div>
                            </div>
                        </div>
                        <div class="checks-row">
                            <span class="check-item ${s.trend === 'bullish' ? 'pass' : s.trend === 'bearish' ? 'fail' : 'neutral'}">${s.trend.toUpperCase()}</span>
                            <span class="check-item ${s.structure === 'bullish' ? 'pass' : s.structure === 'bearish' ? 'fail' : 'neutral'}">Structure: ${s.structure.toUpperCase()}</span>
                            <span class="check-item ${s.rsi > 50 ? 'pass' : 'fail'}">RSI: ${s.rsi.toFixed(1)}</span>
                        </div>
                    </div>
                </div>
            `).join('');
        }
        
        function refreshAnalysis() {
            loadStructureAnalysis();
        }

        function renderNews() {
            const container = document.getElementById('newsFeed');
            const newsItems = [
                { title: 'Market analysis in progress...', time: 'Now' },
                { title: 'Waiting for high-impact events...', time: '--' }
            ];
            container.innerHTML = newsItems.map(n => `
                <div class="news-item">
                    <div class="news-title">${n.title}</div>
                    <div class="news-time">${n.time}</div>
                </div>
            `).join('');
        }

        // ==========================================
        // EVENT HANDLERS
        // ==========================================

        function setupEventListeners() {
            // Tab navigation
            document.querySelectorAll('.nav-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    document.querySelectorAll('[id$="-tab"]').forEach(tab => tab.classList.add('hidden'));
                    document.getElementById(btn.dataset.tab + '-tab').classList.remove('hidden');
                    state.currentTab = btn.dataset.tab;
                    
                    // Load analysis when Analysis tab is clicked
                    if (btn.dataset.tab === 'analysis') {
                        loadStructureAnalysis();
                    }
                });
            });

            // Filter buttons
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.filter = btn.dataset.filter;
                    renderSignals();
                });
            });
        }

        // ==========================================
        // INITIALIZATION
        // ==========================================

        async function init() {
            setupEventListeners();
            renderNews();
            loadPerformance();
            await scanMarkets();
            
            // Auto-refresh every 1 minute for continuous scanning
            setInterval(scanMarkets, 60 * 1000);
        }

        function toggleTelegram(enabled) {
            state.telegramEnabled = enabled;
            localStorage.setItem('protrade_telegram', enabled ? 'on' : 'off');
            console.log('Telegram notifications:', enabled ? 'ON' : 'OFF');
        }

        // Load telegram setting
        try {
            const savedTg = localStorage.getItem('protrade_telegram');
            if (savedTg === 'off') {
                state.telegramEnabled = false;
                document.getElementById('telegramToggle').checked = false;
            }
        } catch(e) {}

        init();
    </script>
</body>
</html>
